!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) - 14 Jul 2023 15:27
!
MODULE WISHART_MODULE_FORWARD_OMP
  USE ISO_C_BINDING
  TYPE, BIND(C) :: WISHART
      REAL(C_DOUBLE) :: gamma
      INTEGER(C_INT) :: m
  END TYPE WISHART

CONTAINS

  FUNCTION ARR_MAX(n, x)
    IMPLICIT NONE
    INTEGER :: n, i
    REAL(kind=8), DIMENSION(n) :: x
    REAL(kind=8) :: arr_max
    arr_max = x(1)
    DO i=2,n
      IF (arr_max .LT. x(i)) arr_max = x(i)
    END DO
  END FUNCTION ARR_MAX

  FUNCTION SQNORM(n, x)
    IMPLICIT NONE
    INTEGER :: n, i
    REAL(kind=8), DIMENSION(n) :: x
    REAL(kind=8) :: sqnorm
    sqnorm = x(1)*x(1)
    DO i=2,n
      sqnorm = sqnorm + x(i)*x(i)
    END DO
  END FUNCTION SQNORM

  SUBROUTINE SUBTRACT(d, x, y, out)
    IMPLICIT NONE
    INTEGER :: d, id
    REAL(kind=8), DIMENSION(d) :: x, y, out
    DO id=1,d
      out(id) = x(id) - y(id)
    END DO
  END SUBROUTINE SUBTRACT

  FUNCTION LOG_SUM_EXP(n, x)
    IMPLICIT NONE
    INTEGER :: n, i
    REAL(kind=8), DIMENSION(n) :: x
    REAL(kind=8) :: log_sum_exp, mx, semx
    INTRINSIC EXP
    INTRINSIC LOG
    mx = ARR_MAX(n, x)
    semx = 0.0
    DO i=1,n
      semx = semx + EXP(x(i) - mx)
    END DO
    log_sum_exp = LOG(semx) + mx
  END FUNCTION LOG_SUM_EXP

  FUNCTION LOG_GAMMA_DISTRIB(a, p)
    IMPLICIT NONE
    INTEGER :: p, j
    REAL(kind=8) :: a, out
    INTRINSIC LOG
    REAL(kind=8) :: arg1
    REAL(kind=8) :: result1
    REAL(kind=8) :: log_gamma_distrib
    out = 0.25*p*(p-1)*LOG(3.1415926)
    DO j=1,p
      arg1 = a + 0.5*(1-j)
      result1 = LGAMMA(arg1)
      out = out + result1
    END DO
    log_gamma_distrib = out
  END FUNCTION LOG_GAMMA_DISTRIB

  FUNCTION LOG_WISHART_PRIOR(p, k, wishart_var, sum_qs, qdiags, icf)
    IMPLICIT NONE
    INTEGER :: p, k, ik
    TYPE(WISHART) :: wishart_var
    REAL(kind=8), DIMENSION(*), INTENT(IN) :: sum_qs, qdiags, icf
    REAL(kind=8) :: log_wishart_prior, c, out, frobenius
    INTEGER :: n, icf_sz, id
    INTRINSIC LOG
    REAL(kind=8) :: arg1
    REAL(kind=8) :: result1
    REAL(kind=8) :: result10
    INTEGER :: arg10
    REAL(kind=8) :: result2
    n = p + wishart_var%m + 1
    icf_sz = p*(p+1)/2
    arg1 = 0.5*n
    result1 = LOG_GAMMA_DISTRIB(arg1, p)
    c = n*p*(LOG(wishart_var%gamma)-0.5*LOG(2.0)) - result1
    out = 0
    DO ik=1,k
      result10 = SQNORM(p, qdiags((ik-1)*p+1:ik*p))
      arg10 = icf_sz - p
      result2 = SQNORM(arg10, icf((ik-1)*icf_sz+p+1:ik*icf_sz))
      frobenius = result10 + result2
      out = out + 0.5*wishart_var%gamma*wishart_var%gamma*frobenius - &
&       wishart_var%m*sum_qs(ik)
    END DO
    log_wishart_prior = out - k*c
  END FUNCTION LOG_WISHART_PRIOR

  SUBROUTINE PREPROCESS_QS(d, k, icf, sum_qs, qdiags)
    IMPLICIT NONE
    INTEGER :: d, k, ik, id
    REAL(kind=8), DIMENSION(*), INTENT(IN) :: icf
    REAL(kind=8), DIMENSION(*), INTENT(OUT) :: sum_qs, qdiags
    INTEGER :: icf_sz
    INTRINSIC EXP
    icf_sz = d*(d+1)/2
    DO ik=1,k
      sum_qs(ik) = 0.
      DO id=1,d
        sum_qs(ik) = sum_qs(ik) + icf((ik-1)*icf_sz+id)
        qdiags((ik-1)*d+id) = EXP(icf((ik-1)*icf_sz+id))
      END DO
    END DO
  END SUBROUTINE PREPROCESS_QS

  SUBROUTINE QTIMESX(d, qdiag, ltri, x, out)
    IMPLICIT NONE
    INTEGER :: d, i, j
    REAL(kind=8), DIMENSION(*), INTENT(IN) :: qdiag, ltri, x
    REAL(kind=8), DIMENSION(*), INTENT(OUT) :: out
    INTEGER :: lparamsidx
    DO i=1,d
      out(i) = qdiag(i)*x(i)
    END DO
    lparamsidx = 1
    DO i=1,d
      DO j=i+1,d
        out(j) = out(j) + ltri(lparamsidx)*x(i)
        lparamsidx = lparamsidx + 1
      END DO
    END DO
  END SUBROUTINE QTIMESX

   SUBROUTINE GMM_OBJECTIVE(d, k, n, alphas, means, icf, x, wishart_var, &
&   err) BIND(c)
    use omp_lib
    IMPLICIT NONE
    integer :: num_threads, thread_id
    INTEGER :: d, k, n, ix, ik
    TYPE(WISHART) :: wishart_var
    REAL(kind=8), DIMENSION(*), INTENT(IN) :: alphas, means, icf, x
    REAL(kind=8), INTENT(OUT) :: err
    REAL(kind=8), DIMENSION(:), ALLOCATABLE :: qdiags, sum_qs, xcentered&
&   , qxcentered, main_term
    INTEGER :: icf_sz, id
    REAL :: const
    INTRINSIC LOG
    REAL(kind=8) :: slse
    REAL(kind=8) :: lse_alphas
    REAL(kind=8) :: result1
    integer :: clock_start, clock_end, clock_rate
    real :: elapsed_time


    const = -(n*d*0.5*LOG(2*3.1415926))
    icf_sz = d*(d+1)/2
    ALLOCATE(qdiags(d*k))
    ALLOCATE(sum_qs(k))
    ALLOCATE(xcentered(d))
    ALLOCATE(qxcentered(d))
    ALLOCATE(main_term(k))
    CALL PREPROCESS_QS(d, k, icf, sum_qs, qdiags)
    slse = 0.
!$OMP PARALLEL DO SHARED(n, k, d, x, means, qdiags, icf, &
!$OMP&   alphas, sum_qs, icf_sz), PRIVATE(ix, ik,main_term, result1, xcentered,qxcentered), &
!$OMP&REDUCTION(+:slse)
    DO ix=1,n
      DO ik=1,k
        CALL SUBTRACT(d, x((ix-1)*d+1:ix*d), means((ik-1)*d+1:ik*d), &
&               xcentered)
        CALL QTIMESX(d, qdiags((ik-1)*d+1:ik*d), icf((ik-1)*icf_sz+d+1:&
&              ik*icf_sz), xcentered, qxcentered)
        result1 = SQNORM(d, qxcentered)
        main_term(ik) = alphas(ik) + sum_qs(ik) - 0.5*result1
      END DO
      result1 = LOG_SUM_EXP(k, main_term)
      slse = slse + result1
    END DO
    lse_alphas = LOG_SUM_EXP(k, alphas)
    result1 = LOG_WISHART_PRIOR(d, k, wishart_var, sum_qs, qdiags, icf)
    err = const + slse - n*lse_alphas + result1
    DEALLOCATE(qdiags)
    DEALLOCATE(sum_qs)
    DEALLOCATE(xcentered)
    DEALLOCATE(qxcentered)
    DEALLOCATE(main_term)

  END SUBROUTINE GMM_OBJECTIVE

END MODULE WISHART_MODULE_FORWARD_OMP

