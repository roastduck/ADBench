!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) - 21 Jul 2023 18:47
!
MODULE BA_MODULE_DIFF
  IMPLICIT NONE
  INTEGER, PARAMETER :: ba_ncamparams=11

CONTAINS
!  Differentiation of sqsum in reverse (adjoint) mode (with options OpenMP):
!   gradient     of useful results: x sqsum
!   with respect to varying inputs: x
! =====================================================================
!                                UTILS
! =====================================================================
  SUBROUTINE SQSUM_B(n, x, xb, sqsumb)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: n
    REAL(kind=8), INTENT(IN) :: x(n)
    REAL(kind=8) :: xb(n)
    INTEGER :: i
    REAL(kind=8) :: sqsumb
    REAL(kind=8) :: sqsum
    DO i=n,1,-1
      xb(i) = xb(i) + 2*x(i)*sqsumb
    END DO
  END SUBROUTINE SQSUM_B

! =====================================================================
!                                UTILS
! =====================================================================
  REAL(kind=8) FUNCTION SQSUM(n, x)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: n
    REAL(kind=8), INTENT(IN) :: x(n)
    INTEGER :: i
    sqsum = 0.0d0
    DO i=1,n
      sqsum = sqsum + x(i)*x(i)
    END DO
  END FUNCTION SQSUM

!  Differentiation of cross in reverse (adjoint) mode (with options OpenMP):
!   gradient     of useful results: out a b
!   with respect to varying inputs: a b
  SUBROUTINE CROSS_B(a, ab, b, bb, out, outb)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: a(3), b(3)
    REAL(kind=8) :: ab(3), bb(3)
    REAL(kind=8) :: out(3)
    REAL(kind=8) :: outb(3)
    ab(1) = ab(1) + b(2)*outb(3) - b(3)*outb(2)
    bb(2) = bb(2) + a(1)*outb(3) - a(3)*outb(1)
    ab(2) = ab(2) + b(3)*outb(1) - b(1)*outb(3)
    bb(1) = bb(1) + a(3)*outb(2) - a(2)*outb(3)
    outb(3) = 0.0_8
    ab(3) = ab(3) + b(1)*outb(2) - b(2)*outb(1)
    bb(3) = bb(3) + a(2)*outb(1) - a(1)*outb(2)
    outb(2) = 0.0_8
  END SUBROUTINE CROSS_B

  SUBROUTINE CROSS(a, b, out)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: a(3), b(3)
    REAL(kind=8), INTENT(OUT) :: out(3)
    out(1) = a(2)*b(3) - a(3)*b(2)
    out(2) = a(3)*b(1) - a(1)*b(3)
    out(3) = a(1)*b(2) - a(2)*b(1)
  END SUBROUTINE CROSS

!  Differentiation of rodrigues_rotate_point in reverse (adjoint) mode (with options OpenMP):
!   gradient     of useful results: rot rotatedpt
!   with respect to varying inputs: rot pt
! =====================================================================
!                               MAIN LOGIC
! =====================================================================
  SUBROUTINE RODRIGUES_ROTATE_POINT_B(rot, rotb, pt, ptb, rotatedpt, &
&   rotatedptb)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: rot(3), pt(3)
    REAL(kind=8) :: rotb(3), ptb(3)
    REAL(kind=8) :: rotatedpt(3)
    REAL(kind=8) :: rotatedptb(3)
    INTEGER :: i
    REAL(kind=8) :: sqtheta, theta, costheta, sintheta, theta_inverse, &
&   tmp
    REAL(kind=8) :: sqthetab, thetab, costhetab, sinthetab, &
&   theta_inverseb, tmpb
    REAL(kind=8), DIMENSION(3) :: w, w_cross_pt, rot_cross_pt
    REAL(kind=8), DIMENSION(3) :: wb, w_cross_ptb, rot_cross_ptb
    INTRINSIC SQRT
    INTRINSIC COS
    INTRINSIC SIN
    REAL(kind=8) :: tempb
    sqtheta = SQSUM(3, rot)
    IF (sqtheta .NE. 0.0d0) THEN
      theta = SQRT(sqtheta)
      costheta = COS(theta)
      sintheta = SIN(theta)
      theta_inverse = 1.0d0/theta
      DO i=1,3
        w(i) = rot(i)*theta_inverse
      END DO
      CALL CROSS(w, pt, w_cross_pt)
      tmp = (w(1)*pt(1)+w(2)*pt(2)+w(3)*pt(3))*(1.0d0-costheta)
      ptb = 0.0_8
      w_cross_ptb = 0.0_8
      wb = 0.0_8
      costhetab = 0.0_8
      tmpb = 0.0_8
      sinthetab = 0.0_8
      DO i=3,1,-1
        ptb(i) = ptb(i) + costheta*rotatedptb(i)
        costhetab = costhetab + pt(i)*rotatedptb(i)
        w_cross_ptb(i) = w_cross_ptb(i) + sintheta*rotatedptb(i)
        sinthetab = sinthetab + w_cross_pt(i)*rotatedptb(i)
        wb(i) = wb(i) + tmp*rotatedptb(i)
        tmpb = tmpb + w(i)*rotatedptb(i)
        rotatedptb(i) = 0.0_8
      END DO
      tempb = (1.0d0-costheta)*tmpb
      costhetab = costhetab - (w(1)*pt(1)+w(2)*pt(2)+w(3)*pt(3))*tmpb
      wb(1) = wb(1) + pt(1)*tempb
      ptb(1) = ptb(1) + w(1)*tempb
      wb(2) = wb(2) + pt(2)*tempb
      ptb(2) = ptb(2) + w(2)*tempb
      wb(3) = wb(3) + pt(3)*tempb
      ptb(3) = ptb(3) + w(3)*tempb
      CALL CROSS_B(w, wb, pt, ptb, w_cross_pt, w_cross_ptb)
      theta_inverseb = 0.0_8
      DO i=3,1,-1
        rotb(i) = rotb(i) + theta_inverse*wb(i)
        theta_inverseb = theta_inverseb + rot(i)*wb(i)
        wb(i) = 0.0_8
      END DO
      thetab = COS(theta)*sinthetab - theta_inverseb/theta**2 - SIN(&
&       theta)*costhetab
      IF (sqtheta .EQ. 0.0) THEN
        sqthetab = 0.0_8
      ELSE
        sqthetab = thetab/(2.0*SQRT(sqtheta))
      END IF
    ELSE
      ptb = 0.0_8
      rot_cross_ptb = 0.0_8
      DO i=3,1,-1
        ptb(i) = ptb(i) + rotatedptb(i)
        rot_cross_ptb(i) = rot_cross_ptb(i) + rotatedptb(i)
        rotatedptb(i) = 0.0_8
      END DO
      CALL CROSS_B(rot, rotb, pt, ptb, rot_cross_pt, rot_cross_ptb)
      sqthetab = 0.0_8
    END IF
    CALL SQSUM_B(3, rot, rotb, sqthetab)
  END SUBROUTINE RODRIGUES_ROTATE_POINT_B

! =====================================================================
!                               MAIN LOGIC
! =====================================================================
  SUBROUTINE RODRIGUES_ROTATE_POINT(rot, pt, rotatedpt)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: rot(3), pt(3)
    REAL(kind=8), INTENT(OUT) :: rotatedpt(3)
    INTEGER :: i
    REAL(kind=8) :: sqtheta, theta, costheta, sintheta, theta_inverse, &
&   tmp
    REAL(kind=8), DIMENSION(3) :: w, w_cross_pt, rot_cross_pt
    INTRINSIC SQRT
    INTRINSIC COS
    INTRINSIC SIN
    sqtheta = SQSUM(3, rot)
    IF (sqtheta .NE. 0.0d0) THEN
      theta = SQRT(sqtheta)
      costheta = COS(theta)
      sintheta = SIN(theta)
      theta_inverse = 1.0d0/theta
      DO i=1,3
        w(i) = rot(i)*theta_inverse
      END DO
      CALL CROSS(w, pt, w_cross_pt)
      tmp = (w(1)*pt(1)+w(2)*pt(2)+w(3)*pt(3))*(1.0d0-costheta)
      DO i=1,3
        rotatedpt(i) = pt(i)*costheta + w_cross_pt(i)*sintheta + w(i)*&
&         tmp
      END DO
    ELSE
      CALL CROSS(rot, pt, rot_cross_pt)
      DO i=1,3
        rotatedpt(i) = pt(i) + rot_cross_pt(i)
      END DO
    END IF
  END SUBROUTINE RODRIGUES_ROTATE_POINT

!  Differentiation of radial_distort in reverse (adjoint) mode (with options OpenMP):
!   gradient     of useful results: rad_params proj
!   with respect to varying inputs: rad_params proj
  SUBROUTINE RADIAL_DISTORT_B(rad_params, rad_paramsb, proj, projb)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: rad_params(2)
    REAL(kind=8) :: rad_paramsb(2)
    REAL(kind=8), INTENT(INOUT) :: proj(2)
    REAL(kind=8), INTENT(INOUT) :: projb(2)
    REAL(kind=8) :: rsq, l
    REAL(kind=8) :: rsqb, lb
    rsq = SQSUM(2, proj)
    l = 1.0d0 + rad_params(1)*rsq + rad_params(2)*rsq*rsq
    CALL PUSHREAL8(proj(1))
    proj(1) = proj(1)*l
    CALL POPREAL8(proj(1))
    lb = proj(2)*projb(2) + proj(1)*projb(1)
    projb(2) = l*projb(2)
    projb(1) = l*projb(1)
    rad_paramsb(1) = rad_paramsb(1) + rsq*lb
    rsqb = (rad_params(1)+2*rsq*rad_params(2))*lb
    rad_paramsb(2) = rad_paramsb(2) + rsq**2*lb
    CALL SQSUM_B(2, proj, projb, rsqb)
  END SUBROUTINE RADIAL_DISTORT_B

  SUBROUTINE RADIAL_DISTORT(rad_params, proj)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: rad_params(2)
    REAL(kind=8), INTENT(INOUT) :: proj(2)
    REAL(kind=8) :: rsq, l
    rsq = SQSUM(2, proj)
    l = 1.0d0 + rad_params(1)*rsq + rad_params(2)*rsq*rsq
    proj(1) = proj(1)*l
    proj(2) = proj(2)*l
  END SUBROUTINE RADIAL_DISTORT

!  Differentiation of project in reverse (adjoint) mode (with options OpenMP):
!   gradient     of useful results: proj
!   with respect to varying inputs: x cam
  SUBROUTINE PROJECT_B(cam, camb, x, xb, proj, projb)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: cam(ba_ncamparams), x(3)
    REAL(kind=8) :: camb(ba_ncamparams), xb(3)
    REAL(kind=8) :: proj(2)
    REAL(kind=8) :: projb(2)
    REAL(kind=8), DIMENSION(3) :: c, xo, xcam
    REAL(kind=8), DIMENSION(3) :: cb, xob, xcamb
    REAL(kind=8) :: tempb
!print *, size(cam)
!print *,cam
    c = cam(4:6)
    xo = x - c
    CALL RODRIGUES_ROTATE_POINT(cam(1:3), xo, xcam)
    proj(1) = xcam(1)/xcam(3)
    proj(2) = xcam(2)/xcam(3)
    CALL PUSHREAL8ARRAY(proj, 2)
    CALL RADIAL_DISTORT(cam(10:11), proj)
    CALL PUSHREAL8(proj(1))
    proj(1) = proj(1)*cam(7) + cam(8)
    CALL POPREAL8(proj(1))
    camb = 0.0_8
    camb(7) = camb(7) + proj(2)*projb(2) + proj(1)*projb(1)
    camb(9) = camb(9) + projb(2)
    projb(2) = cam(7)*projb(2)
    camb(8) = camb(8) + projb(1)
    projb(1) = cam(7)*projb(1)
    CALL POPREAL8ARRAY(proj, 2)
    CALL RADIAL_DISTORT_B(cam(10:11), camb(10:11), proj, projb)
    xcamb = 0.0_8
    tempb = projb(2)/xcam(3)
    projb(2) = 0.0_8
    xcamb(2) = xcamb(2) + tempb
    xcamb(3) = xcamb(3) - xcam(2)*tempb/xcam(3)
    tempb = projb(1)/xcam(3)
    xcamb(1) = xcamb(1) + tempb
    xcamb(3) = xcamb(3) - xcam(1)*tempb/xcam(3)
    CALL RODRIGUES_ROTATE_POINT_B(cam(1:3), camb(1:3), xo, xob, xcam, &
&                           xcamb)
    xb = 0.0_8
    cb = 0.0_8
    xb = xob
    cb = -xob
    camb(4:6) = camb(4:6) + cb
  END SUBROUTINE PROJECT_B

  SUBROUTINE PROJECT(cam, x, proj)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: cam(ba_ncamparams), x(3)
    REAL(kind=8), INTENT(OUT) :: proj(2)
    REAL(kind=8), DIMENSION(3) :: c, xo, xcam
!print *, size(cam)
!print *,cam
    c = cam(4:6)
    xo = x - c
    CALL RODRIGUES_ROTATE_POINT(cam(1:3), xo, xcam)
    proj(1) = xcam(1)/xcam(3)
    proj(2) = xcam(2)/xcam(3)
    CALL RADIAL_DISTORT(cam(10:11), proj)
    proj(1) = proj(1)*cam(7) + cam(8)
    proj(2) = proj(2)*cam(7) + cam(9)
  END SUBROUTINE PROJECT

!  Differentiation of compute_reproj_error in reverse (adjoint) mode (with options OpenMP):
!   gradient     of useful results: err
!   with respect to varying inputs: err x cam
!   RW status of diff variables: err:in-out x:out cam:out
  SUBROUTINE COMPUTE_REPROJ_ERROR_B(cam, camb, x, xb, w, feat, err, errb&
& )
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: cam(ba_ncamparams), x(3), w, feat(2)
    REAL(kind=8) :: camb(ba_ncamparams), xb(3)
    REAL(kind=8) :: err(2)
    REAL(kind=8) :: errb(2)
    REAL(kind=8), DIMENSION(2) :: proj
    REAL(kind=8), DIMENSION(2) :: projb
!print *,err
    projb = 0.0_8
    projb(2) = projb(2) + w*errb(2)
    errb(2) = 0.0_8
    projb(1) = projb(1) + w*errb(1)
    errb(1) = 0.0_8
    CALL PROJECT_B(cam, camb, x, xb, proj, projb)
  END SUBROUTINE COMPUTE_REPROJ_ERROR_B

  SUBROUTINE COMPUTE_REPROJ_ERROR(cam, x, w, feat, err)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: cam(ba_ncamparams), x(3), w, feat(2)
    REAL(kind=8), INTENT(OUT) :: err(2)
    REAL(kind=8), DIMENSION(2) :: proj
    CALL PROJECT(cam, x, proj)
    err(1) = w*(proj(1)-feat(1))
    err(2) = w*(proj(2)-feat(2))
!print *,err
  END SUBROUTINE COMPUTE_REPROJ_ERROR

!  Differentiation of compute_zach_weight_error in reverse (adjoint) mode (with options OpenMP):
!   gradient     of useful results: err
!   with respect to varying inputs: err w
!   RW status of diff variables: err:in-zero w:out
  SUBROUTINE COMPUTE_ZACH_WEIGHT_ERROR_B(w, wb, err, errb)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: w
    REAL(kind=8) :: wb
    REAL(kind=8) :: err
    REAL(kind=8) :: errb
    wb = -(2*w*errb)
    errb = 0.0_8
  END SUBROUTINE COMPUTE_ZACH_WEIGHT_ERROR_B

  SUBROUTINE COMPUTE_ZACH_WEIGHT_ERROR(w, err)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: w
    REAL(kind=8), INTENT(OUT) :: err
    err = 1.0d0 - w*w
  END SUBROUTINE COMPUTE_ZACH_WEIGHT_ERROR

  SUBROUTINE BA_OBJECTIVEFORTRAN(n, m, p, camssize, cams, x, w, obs, &
&   feats, reproj_err, w_err) BIND(c)
    IMPLICIT NONE
!use omp_lib, only: omp_get_max_threads, omp_set_num_threads
!integer :: num_threads
    INTEGER, INTENT(IN) :: n, m, p, camssize
    REAL(kind=8), INTENT(IN) :: cams(camssize), x(3*m), w(p), feats(2*p)
    INTEGER, INTENT(IN) :: obs(2*p)
    REAL(kind=8), INTENT(OUT) :: reproj_err(2*p), w_err(p)
    INTEGER :: i
    INTEGER :: camidx
    INTEGER :: ptidx
!num_threads = omp_get_max_threads()
!print *, "OpenMP线程数:", num_threads
!$OMP PARALLEL DO PRIVATE(i, camidx, ptidx), SHARED(obs, cams, x, feats, &
!$OMP&reproj_err)
    DO i=1,p
      camidx = obs((i-1)*2+1)
      ptidx = obs((i-1)*2+2)
      CALL COMPUTE_REPROJ_ERROR(cams((camidx-1)*ba_ncamparams+1:(camidx-&
&                         1)*ba_ncamparams+ba_ncamparams), x((ptidx-1)*3&
&                         +1:(ptidx-1)*3+3), w(i), feats((i-1)*2+1:(i-1)&
&                         *2+2), reproj_err((i-1)*2+1:(i-1)*2+2))
    END DO
!$OMP PARALLEL DO SHARED(w, w_err)
    DO i=1,p
      CALL COMPUTE_ZACH_WEIGHT_ERROR(w(i), w_err(i))
    END DO
  END SUBROUTINE BA_OBJECTIVEFORTRAN

END MODULE BA_MODULE_DIFF

